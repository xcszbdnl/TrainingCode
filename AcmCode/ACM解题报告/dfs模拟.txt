codeforces_245_a:给定一棵树，每个点有个初始值0，1.最终值0,1。每次可以选择一次点进行一种操作，翻转初始值，翻转该点，则该点的所有子孙中，距离该点层数为偶数的都要翻转
求最少的翻转次数。
首先如果某个点被翻转了，那么要看他的祖先有没有被翻转的，如果祖先被翻转了，那么现在翻转这个点肯定是不明智的。
所以从根看起，根被翻转了那么肯定要翻转根，接下来看根的儿子，根儿子的儿子依次向下。
操作在dfs序上操作。
此题关键考察对dfs序进行操作。以及区间更新。

codeforces_14_a:
在一个树上找两条互不交叉的路径，每条路的长度为1，互不交叉是指不共享任何一个点。
枚举删除的每一条边，将树分成了两个联通分量，求每个联通分量的最长路。两次dfs即可。
注意的是要只有两个联通分量，并且访问上一个联通分量后，vis被重置要保存下来。