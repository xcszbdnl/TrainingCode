codeforces_250_b:
有一个图，每个点有一个权值，现在找到所有的点对，点对之间有路径，如i,j之间有几条路径，定义f(i,j)为所有路径上权值最小点的最大值。现在求所有的f(i,j)
枚举所有点对是不现实的，显然要从边考虑，考虑如果一个一条边加进来的话会有两种可能，一是这条边连接两个不相连接的块，
此时这种情况如果这两个块的点都连接起来了，且在两个块之间的路径都要经过这条边的两个点。如果我们依次把点比这两个点的最小值权值还大的边都加进来的话，这样说明
此时这条边的权值就是所有联通点对的权值。那么答案增加很好计算。
如果连接的两个点属于同一个快，因为是最小值得最大值，即使这条边的权值比原来的小，但是其余点对最大值不变，所以不需要更新。
考察并查集的使用，以及在需要大量枚举的时候反向过来要考虑边，在图上找最小值的时候也要从边去构造。

ural004:
求权值最小环。
有两种思路，一是对每条边E(s,t)删掉之后求s,t的最短路，可以用bellmanFord或者Dijstra求。
二是floyd最小环路模板。顺便学习了如何记录floyd路径记录。
用pre[i][j]表示i...j路径上最后一个点，直接相连的就是pre[i][j] = i;
那么当有dp[i][j] > dp[i][k] + dp[k][j]的时候，pre[i][j] = pre[k][j]。
然后不断逆序遍历即可。
求最小环一开始没有做出来是因为即使知道所有点对之间最短路之后，枚举i,j,k。
路径为i..->j...->k..->i，但是中间明显有重复路径，之后不知道如何去处理。
正解为枚举方式改变：枚举i...->j->k->i，其中j,k和k,i都是直接相连的。
那么就可以枚举k比i,j都大。然后i..->j上的所有路径点都比k小，就选出了路径。
如何保证i..->j上的点都比k小？枚举的时候应该先找最小环，然后再去松弛。
因为假设i..-> k + 1...->j->k是一条路径的话，因为我现在才枚举到k，中间不可能松弛i..->k + 1..->j。
所以也就不存在中间的点比k大了。