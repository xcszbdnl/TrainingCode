codeforces 198 div1 D:
有两种操作，1，对一个子矩阵所有元素进行异或操作。2，对一个子矩阵中所有元素求异或和。
首先对一个子矩阵做所有异或操作可以看成对4个点进行异或操作。（如上题区间操作转化为点操作）
查询一个点的值(x, y)就相当于求a(1, 1, x, y)异或和。
查询子矩阵所有元素异或和，可以看做查询(1, 1, x, y)子矩阵所有元素异或和。
对于某个元素(a, b)，包含它的子矩阵X取值范围为(a, a + 1, ... x),y取值范围为(b, b + 1, ....,y);所以总共有(x - a + 1) * (y - b + 1)个子矩阵包含元素(a, b)；
当(x - a + 1) * (y - b + 1)为偶数的时候，异或和不影响，所以只要计算(x - a + 1) * (y - b + 1)为奇数的时候情况
那么求(1, 1, x, y)相当于对所有(1, 1, a, b)元素异或。
包含(a, b)子矩阵为偶数的就不需要计算了。
考察树状数组区域更新，区间更新。

codeforces 225 div1 C:有一颗以1为根的树，每个节点有一个数值，有两种操作，1 x val, 2 x，
操作1，将x的偶数层子树加上val，奇数层子树减去val。操作2，打印x的值
对树上操作转为dfs序列，区间操作，转区间操作后，因为奇数层和偶数层加的不同。开两颗树状数组。
tree[2][MAX_NUMBER], tree[0]记录偶数层的，tree[1]记录奇数层的。
因为对[x, y]进行一个+val操作，可以看做对a[x] + val, a[y + 1] - val，然后查询a[1] + a[2] + .. + a[x]，即为更新后value[x]的值。
对当前层数+val之后，对相反的奇数层要-val。
如codeforces 198 div1 D所示。

poj1611
裸的并查集。

poj1182
并查集的运用，集合之间的关系表示，增加一个字段来表示和跟的关系r[x]
如果r[x] == 0表示和根同类，r[x] == 1表示根吃x，r[x] == 2表示x吃根。
那么现在如果x,y的关系为r[y],y,z的关系为r[z]，那么x和z的关系则是(r[y] + r[z]) % 3。不妨画个图看看。
现在读入一个陈述：
1.如果x,y在同一个集合里面：
1. 1 x y陈述x,y是同类，
那么根据他们与根的关系来判断，如果r[x] != r[y]，则说明他们不是同类
2. 2 x y陈述x吃y，那么x与根的关系为r[x],y与根的关系为r[y]，那么根与x的关系为3 - r[x],
所以y与x的关系为3 - r[x] + r[y]，x吃y，则表示为 (3 - r[x] + r[y]) % 3 == 1。明显以x为根的话,y对x关系就是1.

如果x,y不在一个集合里面，则合并集合，
现在要修改根的关系。
首先father[x]和x的关系为r[x]，x和y的关系为d - 1，那么father[x]和y的关系为 r[x] + d - 1;
father[y]和y的关系为r[y],那么y和father[y]的关系为3 - r[y]，那么father[x]和father[y]的关系为 r[x] + d - 1 + 3 - r[y]。
更新r[father[y]]即可。

ural 1067:路径创建模拟，递归插入。

ural 1090:
逆序对，树状数组的运用

ural 1350:map的应用

ural 1414:基本Trei树的应用

ural 1439:维护一颗被删除节点的数，接下来需要用当前的K大与其比较，另其左子树大小为s,如果s + k < val[cnt]的话，说明第k大是在左子树
否则的话说明是在右子树。

ural1003:
与poj1182类似。
i, j为偶，则说明i和j - 1的关系为同奇偶。
同理表示为不同奇偶。
r[x] == 0表示和根同奇偶，r[x] == 1表示和根不同奇偶。
那么关系更改就简单很多了比poj1182.
注意一点是，首先要离散化，离散化之后还要注意规定了一个长度，如果他说的大于这个长度很定是假的。
然后答案可能是0.

ural 1028:
树状数组，按X排序后求Y值

ural 1037:模拟,每次分配的时候注意要把以前的少于该时间的内存给回收起来，需要用一个优先队列来保存存活时间最少的内存块。
另外更新时间的时候也要注意同时把内存块优先队列里面的时间也要更新了。

ural 1471:裸的最近公共祖先

ural 1494:依次打入，建模发现是一个栈，模拟栈即可。

ural 1523:K逆序数，树状数组统计求和

hdu 4893:
线段树，支持3种操作，关键在第3种操作，把x变为最近的fi,每个节点维护一个f,维护一个d，f + d == val,那么第三种操作相当于把
d置为0

ural 1701:用val[i]表示与根的距离，那么合并的时候注意根之间的合并关系即可。